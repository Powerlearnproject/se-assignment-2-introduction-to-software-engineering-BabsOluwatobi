[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15208938&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2
Assignment: Introduction to Software Engineering

***SOLUTION***

1. Software Engineering: Software engineering is a systematic and disciplined approach to developing, maintaining, and evolving software systems. It involves the application of engineering principles, methods, and best practices to the design, development, testing, and maintenance of software.

2. Software engineering differs from traditional programming in several ways:
   - Software engineering emphasizes a systematic and organized approach to software development, with well-defined processes, methodologies, and standards.
   - It focuses on the entire software development lifecycle, from requirements gathering to maintenance, rather than just coding.
   - Software engineering promotes principles such as modularity, reusability, maintainability, and scalability, which are essential for large and complex software systems.
   - It involves collaboration between teams, including project managers, analysts, designers, developers, and testers.
   - Software engineering incorporates various techniques and tools, such as requirements management, design patterns, version control, and testing frameworks.

3. The Software Development Life Cycle (SDLC) is a structured process that outlines the phases involved in developing a software system. The main phases are:
   - Requirements gathering: Identifying and documenting the requirements of the software system.
   - Design: Creating the overall architecture, detailed design, and data models for the software.
   - Implementation: Writing the code and developing the software based on the design specifications.
   - Testing: Verifying and validating the software to ensure it meets the requirements and is free of defects.
   - Deployment: Installing and releasing the software to the production environment.
   - Maintenance: Ongoing support, bug fixes, and enhancements to the software after deployment.

4. Agile and Waterfall are two contrasting models of software development:
   - The Waterfall model is a linear and sequential approach, where each phase (requirements, design, implementation, testing, deployment) is completed before moving to the next phase. It is more suitable for projects with well-defined and stable requirements.
   - The Agile model is an iterative and incremental approach, where the software is developed in short iterations or sprints, with frequent feedback and adaptation. It is better suited for projects with changing requirements or dynamic environments.

   Agile methodologies, like Scrum and Kanban, prioritize flexibility, collaboration, and frequent delivery of working software. The Waterfall model is preferred in contexts where requirements are well-understood and unlikely to change, such as in certain government or regulatory projects.

5. Requirements engineering is the process of identifying, documenting, and managing the requirements for a software system. It involves:
   - Eliciting requirements from stakeholders through techniques like interviews, surveys, and prototyping.
   - Analyzing and prioritizing requirements based on factors like importance, feasibility, and risk.
   - Documenting requirements in a clear and unambiguous manner.
   - Managing and tracing requirements throughout the software development lifecycle.

   
6. Modularity is a fundamental principle in software design that involves dividing a software system into smaller, independent modules or components. Each module has a well-defined interface and responsibility, and can be developed, tested, and maintained separately. Modularity improves maintainability by localizing changes and allowing for easier code updates. It also enhances scalability by enabling the addition or modification of modules without impacting the entire system.

7. Software testing is a critical activity in software development to ensure the quality and correctness of the software. The different levels of testing are:
   - Unit testing: Testing individual software components or modules in isolation.
   - Integration testing: Testing the interaction and integration between different components or modules.
   - System testing: Testing the complete integrated system against the specified requirements.
   - Acceptance testing: Testing the system in a real-world environment by end-users to ensure it meets their expectations.

8. Version control systems (VCS) are tools that manage and track changes to source code files and other artifacts over time. They are essential in software development because they:
   - Allow multiple developers to work on the same codebase simultaneously.
   - Provide a history of changes, enabling easy rollbacks or comparisons between versions.
   - Facilitate collaboration and code sharing among team members.
   - Help resolve conflicts when multiple developers modify the same code.


9. A software project manager is responsible for overseeing and coordinating the entire software development process. Key responsibilities include:
   - Planning and scheduling project activities, resources, and timelines.
   - Managing the project budget and controlling costs.
   - Assembling and leading the project team, assigning tasks, and monitoring progress.
   - Communicating with stakeholders and managing expectations.
   - Identifying and mitigating project risks and issues.
   - Ensuring adherence to project methodologies, standards, and best practices.

 
10. Software maintenance involves modifying, updating, and supporting an existing software system after it has been deployed. The different types of maintenance activities are:
    - Corrective maintenance: Fixing defects or bugs in the software.
    - Adaptive maintenance: Modifying the software to adapt to changes in the environment, such as new hardware or operating systems.
    - Perfective maintenance: Enhancing the software by adding new features or improving existing ones.
    - Preventive maintenance: Updating the software to improve future maintainability, performance, or security.


11. Software engineers may face various ethical issues in their work, such as:
    - Privacy and data protection: Ensuring the proper handling and protection of user data and personal information.
    - Intellectual property rights: Respecting copyrights, patents, and trademarks, and avoiding plagiarism or unauthorized use of code or algorithms.
    - Professional conduct: Maintaining integrity, honesty, and objectivity in their work, and avoiding conflicts of interest.
    - Accessibility and inclusivity: Designing software that is accessible to users with disabilities and inclusive for diverse user groups.
    - Environmental and societal impact: Considering the environmental and societal implications of their software solutions.

    

**REFERENCES:**

1. Software Engineering:
   - Sommerville, I. (2016). Software Engineering (10th ed.). Pearson Education.
   - Pressman, R. S. (2014). Software Engineering: A Practitioner's Approach (8th ed.). McGraw-Hill Education.

2. Software Development Life Cycle (SDLC):
   - Balaji, S., & Murugaiyan, M. S. (2012). Waterfall vs. V-Model vs. Agile: A Comparative Study on SDLC. International Journal of Information Technology and Business Management, 2(1), 26-30.

3. Agile vs. Waterfall Models:
   - Nerur, S., Mahapatra, R., & Mangalaraj, G. (2005). Challenges of migrating to agile methodologies. Communications of the ACM, 48(5), 72-78.

4. Requirements Engineering:
   - Pohl, K. (2010). Requirements Engineering: Fundamentals, Principles, and Techniques. Springer.
   - Wiegers, K., & Beatty, J. (2013). Software Requirements (3rd ed.). Microsoft Press.

5. Software Design Principles:
   - Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley Professional.

6. Testing in Software Engineering:
   - Ammann, P., & Offutt, J. (2016). Introduction to Software Testing (2nd ed.). Cambridge University Press.
   - Myers, G. J., Sandler, C., & Badgett, T. (2011). The Art of Software Testing (3rd ed.). Wiley.

7. Version Control Systems:
   - Chacon, S., & Straub, B. (2014). Pro Git (2nd ed.). Apress.
   - Collins-Sussman, B., Fitzpatrick, B. W., & Pilato, C. M. (2011). Version Control with Subversion (2nd ed.). O'Reilly Media.

8. Software Project Management:
   - Schwalbe, K. (2015). Information Technology Project Management (8th ed.). Cengage Learning.
   - Stellman, A., & Greene, J. (2014). Learning Agile: Understanding Scrum, XP, Lean, and Kanban. O'Reilly Media.

9. Software Maintenance:
   - Pigoski, T. M. (1996). Practical Software Maintenance: Best Practices for Managing Your Software Investment. Wiley.
   - Sommerville, I. (2011). Software Engineering (9th ed.). Addison-Wesley.

10. Ethical Considerations in Software Engineering:
    - Gotterbarn, D., Miller, K., & Rogerson, S. (1999). Software Engineering Code of Ethics. Computer, 32(10), 88-92.
    - Spinellis, D. (2003). Code Reading: The Open Source Perspective. Addison-Wesley Professional.

***OLUWATOBI BABARINDE***
***babarindeoluwatobi94@gmail.com***
@BabsOluwatobi